class TEST:

    def permute(self, sortin, permutation):
        assert len(sortin) == len(permutation)
        return [sortin[i] for i in permutation]

    def my_sort(self, inputlist):
        inputlist = zip(inputlist, range(len(inputlist)))
        aux = sorted(inputlist, key = lambda x : x[0])
        sorted2in = [aux[i][1] for i in range(len(aux))]
        list2 = zip(sorted2in, range(len(sorted2in)))
        aux1 = sorted(list2, key = lambda x : x[0])
        in2sorted = [aux1[i][1] for i in range(len(aux1))]
        sort = [aux[i][0] for i in range(len(aux))]
        return sort, in2sorted, sorted2in

    def is_in(self, interval1, interval2):
        union = interval1 & interval2
        return True if ((union == interval1) ^ (union == interval2)) and (interval2.lower != interval1.lower and interval1.upper != interval2.upper)  else False

    def is_out(self, interval1, interval2):
        return True if (interval1.lower != interval2.lower) and (interval2.upper != interval1.upper) and (interval1 & interval2) else False

    def canonical_box(self, inter, inter_i):
        if self.is_in(inter, inter_i):
            if inter.upper < inter_i.upper:
                return 'in I II'
            else:
                return 'in II I'
        elif self.is_out(inter, inter_i):
            if inter.upper < inter_i.upper:
                return 'o I II'
            else:
                return 'o II I'
        elif self.is_separate(inter, inter_i):
            return 's'

    def canonical(self, inter_x, inter_y, inter_z, inter_x_i, inter_y_i, inter_z_i):
        return self.canonical_box(inter_x, inter_x_i),  self.canonical_box(inter_y, inter_y_i),  self.canonical_box(inter_z, inter_z_i)

    def rozbij(self, q, i):
        print(q.interval_x, q.interval_y, q.interval_z)
        print(i.interval_x, i.interval_y, i.interval_z,'\n')
        sort, in2sorted, sorted2in = self.my_sort(self.canonical(q.interval_x, q.interval_y, q.interval_z, i.interval_x, i.interval_y, i.interval_z))

        self.permute([q.interval_x, q.interval_y, q.interval_z], in2sorted)
        self.permute([i.interval_x, i.interval_y, i.interval_z], in2sorted)


        min_x_u, min_x_l, max_x_u, max_x_l, min_y_u, min_y_l, max_y_u, max_y_l, min_z_u, min_z_l, max_z_u, max_z_l = \
            min(q.interval_x.upper, i.interval_x.upper), min(q.interval_x.lower, i.interval_x.lower), max(q.interval_x.upper, i.interval_x.upper), max(q.interval_x.lower, i.interval_x.lower), \
            min(q.interval_y.upper, i.interval_y.upper), min(q.interval_y.lower, i.interval_y.lower), max(q.interval_y.upper, i.interval_y.upper), max(q.interval_y.lower, i.interval_y.lower),\
            min(q.interval_z.upper, i.interval_z.upper), min(q.interval_z.lower, i.interval_z.lower), max(q.interval_z.upper, i.interval_z.upper), max(q.interval_z.lower, i.interval_z.lower)
        inter = [[q.interval_x, q.interval_y, q.interval_z],[i.interval_x, i.interval_y, i.interval_z],
                    [closed(min_y_l, max_y_l), closed(max_y_l, min_y_u), closed(min_y_u, max_y_u)],
                    [closed(min_y_l, max_y_l), closed(max_y_l, min_y_u), closed(min_y_u, max_y_u)],
                    [closed(min_z_l, max_z_l), closed(max_z_l, min_z_u), closed(min_z_u, max_z_u)]]

        if sort == ['in I II', 'in I II', 'in I II']:
            return [box3D(inter[1][0], inter[1][1], inter[1][2])]
        elif sort == ['in II I', 'in II I', 'in II I']:
            return [box3D(inter[0][0], inter[0][1], inter[0][2])]
        elif sort == ['in I II', 'in I II', 'in II I']:
            return [box3D(inter[0][0], inter[0][1], inter[0][2]),
                   box3D(inter[1][0], inter[1][1], inter[4][0]),
                   box3D(inter[1][0], inter[1][1], inter[4][2])]
        elif sort == ['in I II', 'in II I', 'in II I']:
            return [box3D(inter[0][0], inter[0][1], inter[0][2]),
                   box3D(inter[2][0], inter[3][1], inter[4][1]),
                   box3D(inter[2][2], inter[3][1], inter[4][1])]
        #--------------------------------------------------------#
        elif sort == ['in I II', 'in I II', 'o I II']:
            return [box3D(inter[1][0], inter[1][1], inter[1][2]),
                   box3D(inter[0][0], inter[0][1], inter[4][0])]
        elif sort == ['in I II', 'in I II', 'o II I']:
            return [box3D(inter[1][0], inter[1][1], inter[1][2]),
                    box3D(inter[0][0], inter[0][1], inter[4][2])]



class box3D:
    def __init__(self, interval_x, interval_y, interval_z):
        self.interval_x = interval_x
        self.interval_y = interval_y
        self.interval_z = interval_z

    def get_interval_x(self):
        return self.interval_x

    def get_interval_y(self):
        return self.interval_y

    def get_interval_z(self):
        return self.interval_z

    @staticmethod
    def factory(x1, y1, z1, x2, y2, z2):
        return box3D(closed(x1, x2), closed(y1, y2), closed(z1, z2))
from portion import closed
tst = TEST()
int1 = tst.rozbij(box3D(closed(input(), input()), closed(input(), input()), closed(input(), input())), box3D(closed(input(), input()), closed(input(), input()), closed(input(), input())))

for i in range(len(int1)):
    print(int1[i].interval_x, int1[i].interval_y, int1[i].interval_z)
